<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>geneClass: NGS::uGenericNGSExperiment&lt; _CHROM_, _BASE_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_n_g_s.html">NGS</a>::<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>
  </div>
</div>
<div class="contents">
<h1>NGS::uGenericNGSExperiment&lt; _CHROM_, _BASE_ &gt; Class Template Reference</h1><!-- doxytag: class="NGS::uGenericNGSExperiment" -->
<p><a href="class_n_g_s_1_1u_generic_n_g_s_experiment-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aead7adea7c713fe394a32df194bbd310"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::operator=" ref="aead7adea7c713fe394a32df194bbd310" args="(const uGenericNGSExperiment &amp;copFrom)" -->
<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a> &amp;copFrom)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6ee66c0052e5e980a8294fc2f9557c1"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::uGenericNGSExperiment" ref="ad6ee66c0052e5e980a8294fc2f9557c1" args="(const uGenericNGSExperiment &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>uGenericNGSExperiment</b> (const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abecc6612dd04ca35019136d3ffa251a0"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::begin" ref="abecc6612dd04ca35019136d3ffa251a0" args="()&#45;&gt;decltype(ExpMap.begin())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()-&gt;decltype(ExpMap.begin())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82a73d38244039763aad23d434ed3274"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::end" ref="a82a73d38244039763aad23d434ed3274" args="()&#45;&gt;decltype(ExpMap.end())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()-&gt;decltype(ExpMap.end())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b9fbc499c2bb3ff14ff131e396db18"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::begin" ref="af4b9fbc499c2bb3ff14ff131e396db18" args="() const &#45;&gt;decltype(ExpMap.cbegin())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const -&gt;decltype(ExpMap.cbegin())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8748630da034b34d3c9d8463df76676"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::end" ref="ac8748630da034b34d3c9d8463df76676" args="() const &#45;&gt;decltype(ExpMap.cend())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const -&gt;decltype(ExpMap.cend())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_CHROM_&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#abe33b00667894d1ffeea51de69ff8c3f">getSubset</a> (std::string chr, float start, float end, OverlapType options=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a Chrom containing only the sites that overlap the given chr.  <a href="#abe33b00667894d1ffeea51de69ff8c3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1739f6d13a4b044991319c81078235"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getChrom" ref="aec1739f6d13a4b044991319c81078235" args="(const std::string &amp;chrom) const " -->
_CHROM_&nbsp;</td><td class="memItemRight" valign="bottom"><b>getChrom</b> (const std::string &amp;chrom) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7953c13aab1601997707eb758f99af9"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getpChrom" ref="ae7953c13aab1601997707eb758f99af9" args="(const std::string &amp;chrom) const " -->
const _CHROM_ *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getpChrom</b> (const std::string &amp;chrom) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a201f855664f51fb62d67751b5f2abf8b">combine</a> (const _CHROM_ &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a given chrom and add it to the Experiment.  <a href="#a201f855664f51fb62d67751b5f2abf8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8ad30aa0fad4b55537747da0758dc2f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::addSite" ref="ab8ad30aa0fad4b55537747da0758dc2f" args="(const _BASE_ &amp;newSite)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>addSite</b> (const _BASE_ &amp;newSite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a3bc83fc8c2d78feab83809659ea16e52">count</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return our element count.  <a href="#a3bc83fc8c2d78feab83809659ea16e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43588dcb750d35c70ec955ea6380772d"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::isEndfile" ref="a43588dcb750d35c70ec955ea6380772d" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isEndfile</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#ac5b27a5b6fa083004b3e758b61129353">setFileStream</a> (std::ifstream &amp;stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af49a3ef4409c3f3b064cfe5642fff51a"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::isModeGradual" ref="af49a3ef4409c3f3b064cfe5642fff51a" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isModeGradual</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_BASE_&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#aaafa0ea3c7d6df614c05eeccb172725e">getSite</a> (std::string chr, int position) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a specific site from a specific chrom. Overloaded to work with position or an interator, typically got from findPrecedingor findNext.  <a href="#aaafa0ea3c7d6df614c05eeccb172725e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484954d16c975b8ba7b7befc98fc8b01"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSite" ref="a484954d16c975b8ba7b7befc98fc8b01" args="(typename std::vector&lt; _BASE_ &gt;::const_iterator posItr) const " -->
_BASE_&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSite</b> (typename std::vector&lt; _BASE_ &gt;::const_iterator posItr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#ac671ddf4224c04215811289c2feb6e1c">sortSites</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort Every site of every chrom based on location.  <a href="#ac671ddf4224c04215811289c2feb6e1c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a46b9970a16fa795d6d1ab69c9716a963">sortSites</a> (Compare comp, std::function&lt; float(const _BASE_ *)&gt; getStart_funct=nullptr, std::function&lt; float(const _BASE_ *)&gt; getEnd_funct=nullptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the sites vector by applying a certain comparison See documention on Chrom version for indepth comments.  <a href="#a46b9970a16fa795d6d1ab69c9716a963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a10965ecec194db8f0d7433c4bef2d4b1">isSorted</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns false if at least one chrom is unsorted.  <a href="#a10965ecec194db8f0d7433c4bef2d4b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; _BASE_ &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#af36d8b17ad37a84236381cf25f09d270">findPrecedingSite</a> (std::string chr, int position) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an interator pointing to the element of the chr before or after the specified value Note that this is based on the current sort type so may not refer to genomic position. Requires the data to be sorted first.  <a href="#af36d8b17ad37a84236381cf25f09d270"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6552793852edc9115818de799b9d417"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::findNextSite" ref="ac6552793852edc9115818de799b9d417" args="(std::string chr, int position) const " -->
std::vector&lt; _BASE_ &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>findNextSite</b> (std::string chr, int position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a5fd8682491d3d93e7758ea45d4750b41">loadFromTabFile</a> (std::ifstream &amp;stream)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load basic data from a tab delimited file, throw away the result.  <a href="#a5fd8682491d3d93e7758ea45d4750b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a97f261f6f41eb2b2e38002b65b2558f5">loadWithParser</a> (std::ifstream &amp;, std::string)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load basic data from a Parser and load necessary data by passing to object constructor  <a href="#a97f261f6f41eb2b2e38002b65b2558f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f71b1a0326b06965417ef5d48868ef0"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::loadWithParser" ref="a5f71b1a0326b06965417ef5d48868ef0" args="(std::string, std::string)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>loadWithParser</b> (std::string, std::string)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a6b997d3971dfee3702cdf27ddcacbb64">writeAsBedFile</a> (std::ostream &amp;out) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write our data as a legal bed file, filling only the first three columns.  <a href="#a6b997d3971dfee3702cdf27ddcacbb64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CHROMPAR_ , typename _BASEPAR_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a7fb2b4ca975ce5d9319314793542b513">getOverlapping</a> (<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROMPAR_, _BASEPAR_ &gt; &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return every element of THIS overlapping with parameter.  <a href="#a7fb2b4ca975ce5d9319314793542b513"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _BASEPAR_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#aa1610431493e8efe594bf1d27f5e3d99">getOverlapping</a> (<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASEPAR_ &gt; &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as above, but compare a chrom rather then EXP.  <a href="#aa1610431493e8efe594bf1d27f5e3d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a5424916890b721933fb427e3be79cb67">getOverlapping</a> (std::string chr, int start, int end, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415997a0637a80fff88887b50e52f71f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::printChromSortStatus" ref="a415997a0637a80fff88887b50e52f71f" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printChromSortStatus</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a4ad742868f6f266d0d895da26d156a3f">getDistinct</a> (<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a> &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an EXP containing only the unarity sites that do not overlap does of the input structure Overloads include Experiment, Chrom, Site and chr,start,end.  <a href="#a4ad742868f6f266d0d895da26d156a3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5197527b889033f9be52a3eaa16cf38b"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getDistinct" ref="a5197527b889033f9be52a3eaa16cf38b" args="(_CHROM_ &amp;compareChr, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDistinct</b> (_CHROM_ &amp;compareChr, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a612e97c83ffc39d4f38e40818ee2b734"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getDistinct" ref="a612e97c83ffc39d4f38e40818ee2b734" args="(std::string chr, int start, int end, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDistinct</b> (std::string chr, int start, int end, OverlapType type=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a567efe581fee14a8a55b7f97ccc17d44">getDistinct</a> (_BASE_ elem, OverlapType options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f7337c466b77faee99d44edc68482a"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::setChrSize" ref="a10f7337c466b77faee99d44edc68482a" args="(std::string chr, int chrSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setChrSize</b> (std::string chr, int chrSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bc78a1cf13a174ad617d6fd0611dc53"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getChrSize" ref="a1bc78a1cf13a174ad617d6fd0611dc53" args="(std::string chr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getChrSize</b> (std::string chr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#aefac1af7866524dd0bd7510bf2573619">getSubsetCount</a> (const std::string &amp;chr, const float start, const float end, const OverlapType overlap=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return overlap of a specific position for a specific map.  <a href="#aefac1af7866524dd0bd7510bf2573619"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6baaa1731015d7a24d3a03a78e85a7a6"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSubsetCount" ref="a6baaa1731015d7a24d3a03a78e85a7a6" args="(const uGenericNGS &amp;subsetReg, const OverlapType overlap=OverlapType::OVERLAP_PARTIAL)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSubsetCount</b> (const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s.html">uGenericNGS</a> &amp;subsetReg, const OverlapType overlap=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a0fc1ff59c25fa7fbbaaa7e3b77d24549">divideItemsIntoBinofSize</a> (int N, SplitType type=SplitType::STRICT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call divideItemsIntoBinofSize on every container item.  <a href="#a0fc1ff59c25fa7fbbaaa7e3b77d24549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a9e7e360eeffde572dde15dc991dba29b">divideItemsIntoNBins</a> (int N, SplitType type=SplitType::STRICT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split each item into smaller equal size members and replace our vector of items with the new one.  <a href="#a9e7e360eeffde572dde15dc991dba29b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#ac39c10f0e92b2638070889d95b916888">removeSpecificSites</a> (UnaryPredicate pred)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove sites from every chrom for which the predicate is true.  <a href="#ac39c10f0e92b2638070889d95b916888"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BinaryOperation , class InitialValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InitialValue&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#ae27ed6c719061ad4a3ace1f35d51a614">accumulateChromsInfo</a> (BinaryOperation binary_op, InitialValue init) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate information by querying all chromosomes.  <a href="#ae27ed6c719061ad4a3ace1f35d51a614"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryOperation &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#aa223768cd2496d8cef525bd97b649185">computeOnAllChroms</a> (UnaryOperation unary_op) const -&gt; std</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a value for all chromosomes in the experiment and return the resulting collection.  <a href="#aa223768cd2496d8cef525bd97b649185"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryOperation &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a8f44b56d8413e24897bd2878609eac44">computeOnOneChrom</a> (UnaryOperation unary_op, const std::string &amp;chr) const -&gt; std</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a value for all chromosomes in the experiment and return the resulting collection.  <a href="#a8f44b56d8413e24897bd2878609eac44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a9876b7f7c96ff03ca60cac72abb48f4b">getSpecificChroms</a> (UnaryPredicate pred) const -&gt;decltype(ExpMap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chromosomes for which a certain predicate is true.  <a href="#a9876b7f7c96ff03ca60cac72abb48f4b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#aacd28f4b108956c4fa8206e1cd4043f7">applyOnAllChroms</a> (UnaryFunction f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the chromosomes collection by applying a certain function to all chromosomes.  <a href="#aacd28f4b108956c4fa8206e1cd4043f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#afde123d3b6efa3db0661860defed62d5">applyOnOneChrom</a> (UnaryFunction f, const std::string &amp;chr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the chromosomes collection by applying a certain function to one chromosomes.  <a href="#afde123d3b6efa3db0661860defed62d5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a4d7b75799ab0f4c1495102cd121ebbd0">applyOnAllChroms</a> (const UnaryFunction f) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the chromosomes collection by applying a certain function to all chromosomes.  <a href="#a4d7b75799ab0f4c1495102cd121ebbd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a8426313e9a2725cbcec1baa166c2f562">applyOnSites</a> (UnaryFunction f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform site of the EXP by applying a certain function.  <a href="#a8426313e9a2725cbcec1baa166c2f562"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aec6bcddec1cff37bac531cd7def0bfdf"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::applyOnSites" ref="aec6bcddec1cff37bac531cd7def0bfdf" args="(const UnaryFunction f) const " -->
template&lt;class UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>applyOnSites</b> (const UnaryFunction f) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; NGSExpIter &gt;<br class="typebreak"/>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#ae22981320787f2b088c31b59ec78594f">countChromsWithProperty</a> (UnaryPredicate pred) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the chromosomes for which a certain predicate is true.  <a href="#ae22981320787f2b088c31b59ec78594f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NGSExpConstIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a5ed70c12afdf1f1af492d4c63d875a01">maxChrom</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the maximal chromosome according to a certain comparison.  <a href="#a5ed70c12afdf1f1af492d4c63d875a01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NGSExpConstIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a24f67273e8a1cefb012fc0df8c12ce2f">minChrom</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the minimal chromosome according to a certain comparison.  <a href="#a24f67273e8a1cefb012fc0df8c12ce2f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; NGSExpConstIter, <br class="typebreak"/>
NGSExpConstIter &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a918a68998a16b1a4ae727c0d9b13cf50">minAndMaxChroms</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the minimal and maximal chromosomes according to a certain comparison.  <a href="#a918a68998a16b1a4ae727c0d9b13cf50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc148b19b8c97894dc86d802bd5d7f60"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getpChrom" ref="abc148b19b8c97894dc86d802bd5d7f60" args="(const std::string &amp;chrom)" -->
_CHROM_ *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getpChrom</b> (const std::string &amp;chrom)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a64b72bc1e85995e322132cda1aff1678">removeSite</a> (std::string chr, int position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a specific number from the specific subtype. //TODO Should this be public?  <a href="#a64b72bc1e85995e322132cda1aff1678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b8bdf99ea383a3e8ff65523ca467cf2"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::inferChrSize" ref="a6b8bdf99ea383a3e8ff65523ca467cf2" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>inferChrSize</b> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ReadMode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a3c4c93a24a1395be809ac02426fcca0e">op_mode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ed7dc1b547d9ecba259c34df68ad9a3"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::ourStream" ref="a3ed7dc1b547d9ecba259c34df68ad9a3" args="" -->
std::ifstream *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourStream</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c6a8d4a67b02d7b37b0e93bde4cb4e"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::ExpMap" ref="ae3c6a8d4a67b02d7b37b0e93bde4cb4e" args="" -->
std::map&lt; std::string, _CHROM_ &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ExpMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d035c1faed3b285f72bbb50088a2260"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::sortGetStart" ref="a9d035c1faed3b285f72bbb50088a2260" args=")" -->
std::function&lt; float(const <br class="typebreak"/>
_BASE_ *)&nbsp;</td><td class="memItemRight" valign="bottom"><b>sortGetStart</b> ) = nullptr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b95cdf720a3c13e2babc49340824e9"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::sortGetEnd" ref="ab8b95cdf720a3c13e2babc49340824e9" args=")" -->
std::function&lt; float(const <br class="typebreak"/>
_BASE_ *)&nbsp;</td><td class="memItemRight" valign="bottom"><b>sortGetEnd</b> ) = nullptr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b16e7b370e6d74359da179f47b93a48"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::m_comptFunc" ref="a7b16e7b370e6d74359da179f47b93a48" args="" -->
std::function&lt; bool(const <br class="typebreak"/>
_BASE_ &amp;item1, const _BASE_ <br class="typebreak"/>
&amp;item2)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_comptFunc</b> = compareStart</td></tr>
</table>
<h3>template&lt;typename _CHROM_, typename _BASE_&gt;<br/>
 class NGS::uGenericNGSExperiment&lt; _CHROM_, _BASE_ &gt;</h3>

<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae27ed6c719061ad4a3ace1f35d51a614"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::accumulateChromsInfo" ref="ae27ed6c719061ad4a3ace1f35d51a614" args="(BinaryOperation binary_op, InitialValue init) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class BinaryOperation , class InitialValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InitialValue <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::accumulateChromsInfo </td>
          <td>(</td>
          <td class="paramtype">BinaryOperation&nbsp;</td>
          <td class="paramname"> <em>binary_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitialValue&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate information by querying all chromosomes. </p>
<p>This function take a pointer to a function to accumulate some information; this function pointer can either be a) the name of a function taking two parameters, an accumulator and a site or b) a lambda function taking two parameters, an accumulator and a site. In all cases, the function must return the new value of the accumulator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binary_op</em>&nbsp;</td><td>BinaryOperation : Querying function to perform on the chromosomes collection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>InitialValue The initial value of the "accumulator" </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The information accumulated by querying all the chromosomes </dd></dl>

</div>
</div>
<a class="anchor" id="a4d7b75799ab0f4c1495102cd121ebbd0"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::applyOnAllChroms" ref="a4d7b75799ab0f4c1495102cd121ebbd0" args="(const UnaryFunction f) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::applyOnAllChroms </td>
          <td>(</td>
          <td class="paramtype">const UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the chromosomes collection by applying a certain function to all chromosomes. </p>
<p>This function take a pointer to a function to transform the chromosomes collection; this function pointer can either be a) the name of a function taking a chrom by reference, b) a lambda function taking a chrom by reference or c) a member method of a chrom using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>unary_op, the operation that was performed on all chromosomes </dd></dl>

</div>
</div>
<a class="anchor" id="aacd28f4b108956c4fa8206e1cd4043f7"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::applyOnAllChroms" ref="aacd28f4b108956c4fa8206e1cd4043f7" args="(UnaryFunction f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::applyOnAllChroms </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the chromosomes collection by applying a certain function to all chromosomes. </p>
<p>This function take a pointer to a function to transform the chromosomes collection; this function pointer can either be a) the name of a function taking a site by reference, b) a lambda function taking a site by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>unary_op, the operation that was performed on all chromosomes </dd></dl>

</div>
</div>
<a class="anchor" id="afde123d3b6efa3db0661860defed62d5"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::applyOnOneChrom" ref="afde123d3b6efa3db0661860defed62d5" args="(UnaryFunction f, const std::string &amp;chr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::applyOnOneChrom </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>chr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the chromosomes collection by applying a certain function to one chromosomes. </p>
<p>This function take a pointer to a function to transform a single chrom ; this function pointer can either be a) the name of a function taking a chrom by reference, b) a lambda function taking a chrom by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>unary_op, the operation that was performed on all chromosomes </dd></dl>

</div>
</div>
<a class="anchor" id="a8426313e9a2725cbcec1baa166c2f562"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::applyOnSites" ref="a8426313e9a2725cbcec1baa166c2f562" args="(UnaryFunction f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::applyOnSites </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform site of the EXP by applying a certain function. </p>
<p>This function take a pointer to a function to transform; this function pointer can either be a) the name of a function taking a site by reference, b) a lambda function taking a site by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>unary_op, the operation that was performed on all sites Const version of its equivalent </dd></dl>

</div>
</div>
<a class="anchor" id="a201f855664f51fb62d67751b5f2abf8b"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::combine" ref="a201f855664f51fb62d67751b5f2abf8b" args="(const _CHROM_ &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::combine </td>
          <td>(</td>
          <td class="paramtype">const _CHROM_ &amp;&nbsp;</td>
          <td class="paramname"> <em>inputChrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a given chrom and add it to the Experiment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inputChrom</em>&nbsp;</td><td>const _CHROM_&amp; Chrom to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aa223768cd2496d8cef525bd97b649185"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::computeOnAllChroms" ref="aa223768cd2496d8cef525bd97b649185" args="(UnaryOperation unary_op) const &#45;&gt; std" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::computeOnAllChroms </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&nbsp;</td>
          <td class="paramname"> <em>unary_op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a value for all chromosomes in the experiment and return the resulting collection. </p>
<p>This function take a pointer to a function to perform on all the chromosomes in the collection; this function pointer can either be a) the name of a function taking a chromosome by reference, b) a lambda function taking a chromosome by reference or c) a member method of a chromosome using "mem_fun_ref". In all cases, the function must return a non void value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on all the chromosomes of the experiment </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A collection of values computed on each chromosome by unary_op </dd></dl>

</div>
</div>
<a class="anchor" id="a8f44b56d8413e24897bd2878609eac44"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::computeOnOneChrom" ref="a8f44b56d8413e24897bd2878609eac44" args="(UnaryOperation unary_op, const std::string &amp;chr) const &#45;&gt; std" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::computeOnOneChrom </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&nbsp;</td>
          <td class="paramname"> <em>unary_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>chr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a value for all chromosomes in the experiment and return the resulting collection. </p>
<p>This function take a pointer to a function to perform on all the chromosomes in the collection; this function pointer can either be a) the name of a function taking a chromosome by reference, b) a lambda function taking a chromosome by reference or c) a member method of a chromosome using "mem_fun_ref". In all cases, the function must return a non void value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on all the chromosomes of the experiment </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A collection of values computed on each chromosome by unary_op </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc83fc8c2d78feab83809659ea16e52"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::count" ref="a3bc83fc8c2d78feab83809659ea16e52" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long long <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return our element count. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int : Number of elements </dd></dl>

</div>
</div>
<a class="anchor" id="ae22981320787f2b088c31b59ec78594f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::countChromsWithProperty" ref="ae22981320787f2b088c31b59ec78594f" args="(UnaryPredicate pred) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;NGSExpIter&gt;::difference_type <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::countChromsWithProperty </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the chromosomes for which a certain predicate is true. </p>
<p>This function take a pointer to a predicate function; this function pointer can either be a) * the name of a function taking a chromosome by reference, b) a lambda function taking a chromosome by reference or c) a member method of a chromosome using "mem_fun_ref". In all cases, the function must return a boolean; true is the predicate is true, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>UnaryPredicate : Unary predicate to evaluate on all chromosomes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of chromosomes for which the predicate is true </dd></dl>

</div>
</div>
<a class="anchor" id="a0fc1ff59c25fa7fbbaaa7e3b77d24549"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::divideItemsIntoBinofSize" ref="a0fc1ff59c25fa7fbbaaa7e3b77d24549" args="(int N, SplitType type=SplitType::STRICT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::divideItemsIntoBinofSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SplitType::STRICT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call divideItemsIntoBinofSize on every container item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>int : Size of the members to build in BP </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>SplitType : How to manage splits that are not a multiple of N. Possible : STRICT - IGNORE - FILL - ADD </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7e360eeffde572dde15dc991dba29b"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::divideItemsIntoNBins" ref="a9e7e360eeffde572dde15dc991dba29b" args="(int N, SplitType type=SplitType::STRICT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::divideItemsIntoNBins </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SplitType::STRICT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split each item into smaller equal size members and replace our vector of items with the new one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>int : Number of bins to make </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>SplitType : How to manage splits that are not a multiple of N. Possible : STRICT - IGNORE - FILL - ADD </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="af36d8b17ad37a84236381cf25f09d270"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::findPrecedingSite" ref="af36d8b17ad37a84236381cf25f09d270" args="(std::string chr, int position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; _BASE_ &gt;::const_iterator <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::findPrecedingSite </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an interator pointing to the element of the chr before or after the specified value Note that this is based on the current sort type so may not refer to genomic position. Requires the data to be sorted first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::string</em>&nbsp;</td><td>chrom to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to value or nullptr if invalid chr. </dd></dl>

</div>
</div>
<a class="anchor" id="a567efe581fee14a8a55b7f97ccc17d44"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getDistinct" ref="a567efe581fee14a8a55b7f97ccc17d44" args="(_BASE_ elem, OverlapType options)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getDistinct </td>
          <td>(</td>
          <td class="paramtype">_BASE_&nbsp;</td>
          <td class="paramname"> <em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ok from here </p>

</div>
</div>
<a class="anchor" id="a4ad742868f6f266d0d895da26d156a3f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getDistinct" ref="a4ad742868f6f266d0d895da26d156a3f" args="(uGenericNGSExperiment &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getDistinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>compareExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an EXP containing only the unarity sites that do not overlap does of the input structure Overloads include Experiment, Chrom, Site and chr,start,end. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>compareExp</em>&nbsp;</td><td><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&amp; Input, copies exist as mentionned prio </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>OverlapType How we determine if overlapping or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uGenericNGSExperiment&lt;_CHROM_,_BASE_&gt; Experiment containing the sites in there appropriate Chroms </dd></dl>

</div>
</div>
<a class="anchor" id="a5424916890b721933fb427e3be79cb67"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getOverlapping" ref="a5424916890b721933fb427e3be79cb67" args="(std::string chr, int start, int end, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getOverlapping </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temp </p>

</div>
</div>
<a class="anchor" id="aa1610431493e8efe594bf1d27f5e3d99"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getOverlapping" ref="aa1610431493e8efe594bf1d27f5e3d99" args="(uGenericNGSChrom&lt; _BASEPAR_ &gt; &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
<div class="memtemplate">
template&lt;typename _BASEPAR_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getOverlapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASEPAR_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>compareChrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as above, but compare a chrom rather then EXP. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a></em>&nbsp;</td><td>compareChrom : Experiment to check for overlaps </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>OverlapType What overlap to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uGenericNGSExperiment&lt;_CHROM_,_BASE_&gt; Experiment containing all elements from THIS that overlap with parameter. See above, but using fixed positions </dd></dl>

</div>
</div>
<a class="anchor" id="a7fb2b4ca975ce5d9319314793542b513"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getOverlapping" ref="a7fb2b4ca975ce5d9319314793542b513" args="(uGenericNGSExperiment&lt; _CHROMPAR_, _BASEPAR_ &gt; &amp;compareExp, OverlapType type=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
<div class="memtemplate">
template&lt;typename _CHROMPAR_ , typename _BASEPAR_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getOverlapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt; _CHROMPAR_, _BASEPAR_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>compareExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return every element of THIS overlapping with parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a></em>&nbsp;</td><td>compareExp : Experiment to check for overlaps </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>OverlapType What overlap to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uGenericNGSExperiment&lt;_CHROM_,_BASE_&gt; Experiment containing all elements from THIS that overlap with parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="aaafa0ea3c7d6df614c05eeccb172725e"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSite" ref="aaafa0ea3c7d6df614c05eeccb172725e" args="(std::string chr, int position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BASE_ <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getSite </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a specific site from a specific chrom. Overloaded to work with position or an interator, typically got from findPrecedingor findNext. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chr</em>&nbsp;</td><td>std::string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>int </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>_BASE_ </dd></dl>

</div>
</div>
<a class="anchor" id="a9876b7f7c96ff03ca60cac72abb48f4b"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSpecificChroms" ref="a9876b7f7c96ff03ca60cac72abb48f4b" args="(UnaryPredicate pred) const &#45;&gt;decltype(ExpMap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getSpecificChroms </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chromosomes for which a certain predicate is true. </p>
<p>This function take a pointer to a predicate function; this function pointer can either be a) * the name of a function taking a chromosome by reference, b) a lambda function taking a chromosome by reference or c) a member method of a chromosome using "mem_fun_ref". In all cases, the function must return a boolean; true is the predicate is true, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>UnaryPredicate : Unary predicate to evaluate on all chromosomes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A collection containing all the chromosomes for which the predicate is true </dd></dl>

</div>
</div>
<a class="anchor" id="abe33b00667894d1ffeea51de69ff8c3f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSubset" ref="abe33b00667894d1ffeea51de69ff8c3f" args="(std::string chr, float start, float end, OverlapType options=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_CHROM_ <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getSubset </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Chrom containing only the sites that overlap the given chr. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chr</em>&nbsp;</td><td>std::string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>int </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>int </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>OverlapType </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>_CHROM_ </dd></dl>

</div>
</div>
<a class="anchor" id="aefac1af7866524dd0bd7510bf2573619"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::getSubsetCount" ref="aefac1af7866524dd0bd7510bf2573619" args="(const std::string &amp;chr, const float start, const float end, const OverlapType overlap=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::getSubsetCount </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OverlapType&nbsp;</td>
          <td class="paramname"> <em>overlap</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return overlap of a specific position for a specific map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chr</em>&nbsp;</td><td>std::string : Map Key ( chrom) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>int : Start position, must be positive </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>int : End position, must be &gt;= start </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlap</em>&nbsp;</td><td>int : Type of overlap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int </dd></dl>

</div>
</div>
<a class="anchor" id="a10965ecec194db8f0d7433c4bef2d4b1"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::isSorted" ref="a10965ecec194db8f0d7433c4bef2d4b1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::isSorted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns false if at least one chrom is unsorted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the experiment is sorted </dd></dl>

</div>
</div>
<a class="anchor" id="a5fd8682491d3d93e7758ea45d4750b41"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::loadFromTabFile" ref="a5fd8682491d3d93e7758ea45d4750b41" args="(std::ifstream &amp;stream)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::loadFromTabFile </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>load basic data from a tab delimited file, throw away the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>std::ifstream&amp; file to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a97f261f6f41eb2b2e38002b65b2558f5"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::loadWithParser" ref="a97f261f6f41eb2b2e38002b65b2558f5" args="(std::ifstream &amp;, std::string)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::loadWithParser </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>pStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>pType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>load basic data from a Parser and load necessary data by passing to object constructor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>std::ifstream&amp; file to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a5ed70c12afdf1f1af492d4c63d875a01"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::maxChrom" ref="a5ed70c12afdf1f1af492d4c63d875a01" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NGSExpConstIter <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::maxChrom </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the maximal chromosome according to a certain comparison. </p>
<p>This function take a pointer to a function to find the maximal chromosome; this function pointer can either be a) the name of a function taking two chromosomes as parameters, b) a lambda function taking two chromosomes as parameters or c) a member method of a chromosome taking another chromosome as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the maximal chromosome </dd></dl>

</div>
</div>
<a class="anchor" id="a918a68998a16b1a4ae727c0d9b13cf50"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::minAndMaxChroms" ref="a918a68998a16b1a4ae727c0d9b13cf50" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;NGSExpConstIter, NGSExpConstIter&gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::minAndMaxChroms </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the minimal and maximal chromosomes according to a certain comparison. </p>
<p>This function take a pointer to a function to find the minimal and maximal chromosomes; this function pointer can either be a) the name of a function taking two chromosomes as parameters, b) a lambda function taking two chromosomes as parameters or c) a member method of a chromosome taking another chromosome as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators: the first indicates the minimal chromosome and the second, the maximal chromosome End STL wrappers </dd></dl>

</div>
</div>
<a class="anchor" id="a24f67273e8a1cefb012fc0df8c12ce2f"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::minChrom" ref="a24f67273e8a1cefb012fc0df8c12ce2f" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NGSExpConstIter <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::minChrom </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the minimal chromosome according to a certain comparison. </p>
<p>This function take a pointer to a function to find the minimal chromosome; this function pointer can either be a) the name of a function taking two chromosomes as parameters, b) a lambda function taking two chromosomes as parameters or c) a member method of a chromosome taking another chromosome as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the chromosomes collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the minimal chromosome </dd></dl>

</div>
</div>
<a class="anchor" id="a64b72bc1e85995e322132cda1aff1678"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::removeSite" ref="a64b72bc1e85995e322132cda1aff1678" args="(std::string chr, int position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::removeSite </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a specific number from the specific subtype. //TODO Should this be public? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chr</em>&nbsp;</td><td>std::string : Key to map element (chrom) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>int : position to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt;_CHROM_, </dd></dl>

</div>
</div>
<a class="anchor" id="ac39c10f0e92b2638070889d95b916888"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::removeSpecificSites" ref="ac39c10f0e92b2638070889d95b916888" args="(UnaryPredicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::removeSpecificSites </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove sites from every chrom for which the predicate is true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>UnaryPredicate Predicate to test, follows standard pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void Wrappers around the STL algorithms </dd></dl>

</div>
</div>
<a class="anchor" id="ac5b27a5b6fa083004b3e758b61129353"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::setFileStream" ref="ac5b27a5b6fa083004b3e758b61129353" args="(std::ifstream &amp;stream)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::setFileStream </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For graduel loading </p>

</div>
</div>
<a class="anchor" id="a46b9970a16fa795d6d1ab69c9716a963"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::sortSites" ref="a46b9970a16fa795d6d1ab69c9716a963" args="(Compare comp, std::function&lt; float(const _BASE_ *)&gt; getStart_funct=nullptr, std::function&lt; float(const _BASE_ *)&gt; getEnd_funct=nullptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::sortSites </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float(const _BASE_ *)&gt;&nbsp;</td>
          <td class="paramname"> <em>getStart_funct</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float(const _BASE_ *)&gt;&nbsp;</td>
          <td class="paramname"> <em>getEnd_funct</em> = <code>nullptr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the sites vector by applying a certain comparison See documention on Chrom version for indepth comments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

<p><p>&lt; AS there are two SorSites functions, we must specify this rather clunky signature so it knows what overload to use </p>
</p>

</div>
</div>
<a class="anchor" id="ac671ddf4224c04215811289c2feb6e1c"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::sortSites" ref="ac671ddf4224c04215811289c2feb6e1c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::sortSites </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort Every site of every chrom based on location. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">uGenericNGSExperiment</a>&lt;_CHROM_, </dd></dl>

</div>
</div>
<a class="anchor" id="a6b997d3971dfee3702cdf27ddcacbb64"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::writeAsBedFile" ref="a6b997d3971dfee3702cdf27ddcacbb64" args="(std::ostream &amp;out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_ , typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::writeAsBedFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write our data as a legal bed file, filling only the first three columns. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>std::ofstream&amp; stream to write to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3c4c93a24a1395be809ac02426fcca0e"></a><!-- doxytag: member="NGS::uGenericNGSExperiment::op_mode" ref="a3c4c93a24a1395be809ac02426fcca0e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CHROM_, typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReadMode <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html">NGS::uGenericNGSExperiment</a>&lt; _CHROM_, _BASE_ &gt;::<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_experiment.html#a3c4c93a24a1395be809ac02426fcca0e">op_mode</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Are we loading gradually? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="u_format_experiment_8h_source.html">uFormatExperiment.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Nov 8 15:47:06 2012 for geneClass by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
