<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>geneClass: NGS::uGenericNGSChrom&lt; _BASE_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_n_g_s.html">NGS</a>::<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>
  </div>
</div>
<div class="contents">
<h1>NGS::uGenericNGSChrom&lt; _BASE_ &gt; Class Template Reference</h1><!-- doxytag: class="NGS::uGenericNGSChrom" -->
<p><a href="class_n_g_s_1_1u_generic_n_g_s_chrom-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e635c056710542c503606c308285a2"></a><!-- doxytag: member="NGS::uGenericNGSChrom::inferChrSize" ref="a62e635c056710542c503606c308285a2" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>inferChrSize</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a9a78b5ccc122f01af19661d0096544ae">~uGenericNGSChrom</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23c2862ec031b16afde618c6fa02c5c"></a><!-- doxytag: member="NGS::uGenericNGSChrom::outputBedFormat" ref="ac23c2862ec031b16afde618c6fa02c5c" args="(std::ostream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>outputBedFormat</b> (std::ostream &amp;out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a8d95d9b7a55b22e8b3de26e937872a40">printStats</a> (std::ostream &amp;out) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#ab868dd6578267b54bda07a2cfd6f5505">divideItemsIntoNBins</a> (int N, SplitType type=SplitType::STRICT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split each item into smaller equal size members and replace our vector of items with the new one.  <a href="#ab868dd6578267b54bda07a2cfd6f5505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a184e00646860b74d0f27bae38452b747">divideItemsIntoBinofSize</a> (int N, SplitType type=SplitType::STRICT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide each member into smaller members of size N, sorting the leftover according to our SplitType.  <a href="#a184e00646860b74d0f27bae38452b747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VecGenConstIter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a3d07b9493b8e1d89f0682a9480f8c926">findPrecedingSite</a> (const float position) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find first item preceding a given value for our current sort type. Data must be sorted.  <a href="#a3d07b9493b8e1d89f0682a9480f8c926"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VecGenConstIter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a9dc4ee72a213ba76b81cfb21cca36441">findNextSite</a> (const float position) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ddaf377a3d74fcd4d38c36a07506058"></a><!-- doxytag: member="NGS::uGenericNGSChrom::generateRandomSite" ref="a6ddaf377a3d74fcd4d38c36a07506058" args="(const int size, std::mt19937 &amp;engine, const uGenericNGSChrom&lt; T2 &gt; &amp;exclList, const int sigma=0, const std::string ID=&quot;&quot;) const " -->
template&lt;class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_BASE_&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>generateRandomSite</b> (const int size, std::mt19937 &amp;engine, const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; T2 &gt; &amp;exclList, const int sigma=0, const std::string ID=&quot;&quot;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_BASE_&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a5a38257e7c63a847d6744cf8fa00271c">generateRandomSite</a> (const int size, std::mt19937 &amp;engine, const int sigma=0, const std::string ID=&quot;&quot;) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a038c23c059998ea8b3db2717721cc1db"></a><!-- doxytag: member="NGS::uGenericNGSChrom::addNRandomSite" ref="a038c23c059998ea8b3db2717721cc1db" args="(const int size, const int n, std::mt19937 &amp;engine, const uGenericNGSChrom&lt; T2 &gt; &amp;exclList, const int sigma=0, const std::string ID=&quot;&quot;)" -->
template&lt;class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>addNRandomSite</b> (const int size, const int n, std::mt19937 &amp;engine, const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; T2 &gt; &amp;exclList, const int sigma=0, const std::string ID=&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d6cd4b76c139c9f0329d12eec9aec0"></a><!-- doxytag: member="NGS::uGenericNGSChrom::addNRandomSite" ref="ad6d6cd4b76c139c9f0329d12eec9aec0" args="(const int size, const int n, std::mt19937 &amp;engine, const int sigma=0, const std::string ID=&quot;&quot;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>addNRandomSite</b> (const int size, const int n, std::mt19937 &amp;engine, const int sigma=0, const std::string ID=&quot;&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a22a93892f0b960712da5b432b0ff4fd5"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getOverlapping" ref="a22a93892f0b960712da5b432b0ff4fd5" args="(uGenericNGSChrom&lt; T2 &gt; &amp;compareExp, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const " -->
template&lt;class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>getOverlapping</b> (<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; T2 &gt; &amp;compareExp, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2cb8ce0416fe1b993a3b0d6868877aab"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getNotOverlapping" ref="a2cb8ce0416fe1b993a3b0d6868877aab" args="(uGenericNGSChrom&lt; T2 &gt; &amp;compareExp, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const " -->
template&lt;class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>getNotOverlapping</b> (<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; T2 &gt; &amp;compareExp, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#af40976c64bf6a698ca0687d6461a17f7">getDistinct</a> (std::string chr, int start, int end, OverlapType options=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a0ba1c72585a69863e62e83123b6113c2">getSubset</a> (float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a subset of our data that overlaps range start/end, based on current sort type.  <a href="#a0ba1c72585a69863e62e83123b6113c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a7e09651073fba5b980fcaae21b51c958">removeSubset</a> (float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return a subSet based on the current comparison value  <a href="#a7e09651073fba5b980fcaae21b51c958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#aba4e0d6c33afa5c9b21049800d3c26d4">addSite</a> (_BASE_ newSite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a new element to our chrom, throw out_of_mem if impossible  <a href="#aba4e0d6c33afa5c9b21049800d3c26d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#aed39f7a2f063bd2cabb41d34460d9b89">getSubsetCount</a> (float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the count of a data subset, based on the current sort type. Please see manual for correct usage of this category of function  <a href="#aed39f7a2f063bd2cabb41d34460d9b89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a36d32f9c25058c20674309b6202116d2">getSortedStatus</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b143f2aebfe2d80665a263aa5337761"></a><!-- doxytag: member="NGS::uGenericNGSChrom::count" ref="a8b143f2aebfe2d80665a263aa5337761" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>count</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a5916a4a249e0603245a00481497568fd">getChromSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a5b2f432a7bbbb9a8bafa275e43963329">setChromSize</a> (long int chromS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set element collection max size.  <a href="#a5b2f432a7bbbb9a8bafa275e43963329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#adcbb0ab03b3d08f03e5adbef3af160a5">getChr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a9db4be4700962c62a316e0d4d4fd4e04">setChr</a> (std::string pchr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_BASE_&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a22b84b392703c323740c8c9b2b4e09f8">getSite</a> (int position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; _BASE_ &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a204206f40cee44b3bfed9883466cb8c1">returnVecData</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryOperation &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a24e63c9701505c27a3d1be8fa2e31e8a">computeOnAllSites</a> (UnaryOperation unary_op)-&gt; std</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a value for all sites in the chromosome and return the resulting collection.  <a href="#a24e63c9701505c27a3d1be8fa2e31e8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; _BASE_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a65e5ec272677a8de6427b2ec651a23f5">getSpecificSites</a> (UnaryPredicate pred) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sites for which a certain predicate is true.  <a href="#a65e5ec272677a8de6427b2ec651a23f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a339b7e7166b89458304d15a130c49705">removeSpecificSites</a> (UnaryPredicate pred)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove sites for which the predicate is true.  <a href="#a339b7e7166b89458304d15a130c49705"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryOperation &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryOperation&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a2d0fc188e5e4fbe9ff84ea191ef70d22">applyOnAllSites</a> (UnaryOperation f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the sites collection by applying a certain function to all sites.  <a href="#a2d0fc188e5e4fbe9ff84ea191ef70d22"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5668ca8f01b3670490d819bed0f5aecf"></a><!-- doxytag: member="NGS::uGenericNGSChrom::applyOnAllSites" ref="a5668ca8f01b3670490d819bed0f5aecf" args="(const UnaryOperation f) const " -->
template&lt;class UnaryOperation &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryOperation&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>applyOnAllSites</b> (const UnaryOperation f) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BinaryOperation , class InitialValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InitialValue&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a5c23b9fbde17c1ad07dbc60517ead481">accumulateSitesInfo</a> (BinaryOperation binary_op, InitialValue init) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate information by querying all sites.  <a href="#a5c23b9fbde17c1ad07dbc60517ead481"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a8f41ebe6fe8599edac708013695ac125">sortSites</a> (Compare comp, std::function&lt; float(const _BASE_ *)&gt; getStart_funct=nullptr, std::function&lt; float(const _BASE_ *)&gt; getEnd_funct=nullptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the sites vector by applying a certain comparison.  <a href="#a8f41ebe6fe8599edac708013695ac125"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a65beb951fddad09f5c9fc450718e158c">sortSites</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default sort using the start position as a the comparison point.  <a href="#a65beb951fddad09f5c9fc450718e158c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a0b4abf5d52df7b9e0107c35b7e9b18c8">isSorted</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates if the sites collection is sorted according to a certain comparison.  <a href="#a0b4abf5d52df7b9e0107c35b7e9b18c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#aa375dd388e7bdf9ad0759a5168bd20fe">isSorted</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates if the sites collection is sorted ascendingly according to their start position.  <a href="#aa375dd388e7bdf9ad0759a5168bd20fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VecGenConstIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#ae62494273a84d618bb17f7d21f68eb0f">minSite</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the minimal site according to a certain comparison.  <a href="#ae62494273a84d618bb17f7d21f68eb0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VecGenConstIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a9c73ad4d4eafa9495a19b6ec1326ce34">maxSite</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the maximal site according to a certain comparison.  <a href="#a9c73ad4d4eafa9495a19b6ec1326ce34"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; VecGenConstIter, <br class="typebreak"/>
VecGenConstIter &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a445dec74ed2220a7c777ea46783c6db5">minAndMaxSites</a> (Compare comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the minimal and maximal sites according to a certain comparison.  <a href="#a445dec74ed2220a7c777ea46783c6db5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; VecGenIter &gt;<br class="typebreak"/>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#afac963887607b1a6b0694eb8612e2293">countSitesWithProperty</a> (UnaryPredicate p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the number of sites for which a certain predicate is true.  <a href="#afac963887607b1a6b0694eb8612e2293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a113a2ed67ec259e29405f351772ecbd6"></a><!-- doxytag: member="NGS::uGenericNGSChrom::uGenericNGSChrom" ref="a113a2ed67ec259e29405f351772ecbd6" args="(std::string consString)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>uGenericNGSChrom</b> (std::string consString)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a20a6b72a8830cab80c00fa2685b36a6b">uGenericNGSChrom</a> (std::string consString, long int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct with name and size.  <a href="#a20a6b72a8830cab80c00fa2685b36a6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c013c287a7da2607f8872db4e0f50bb"></a><!-- doxytag: member="NGS::uGenericNGSChrom::uGenericNGSChrom" ref="a7c013c287a7da2607f8872db4e0f50bb" args="(std::vector&lt; _BASE_ &gt;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>uGenericNGSChrom</b> (std::vector&lt; _BASE_ &gt;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#ac5b4972114393cb342415b4a8a52eeaf">countUnique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dffae387b9e7c847e815bf393d1650e"></a><!-- doxytag: member="NGS::uGenericNGSChrom::begin" ref="a8dffae387b9e7c847e815bf393d1650e" args="() const &#45;&gt;decltype(VecSites.cbegin())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const -&gt;decltype(VecSites.cbegin())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d832429cf23bf121a35c78b6bc45218"></a><!-- doxytag: member="NGS::uGenericNGSChrom::end" ref="a3d832429cf23bf121a35c78b6bc45218" args="() const &#45;&gt;decltype(VecSites.cend())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const -&gt;decltype(VecSites.cend())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">auto&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a373facfa4538e9d3ce035b197855cb02">begin</a> ()-&gt;decltype(VecSites.begin())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4232c627ff1bfaef9ec239e1f448c48f"></a><!-- doxytag: member="NGS::uGenericNGSChrom::end" ref="a4232c627ff1bfaef9ec239e1f448c48f" args="()&#45;&gt;decltype(VecSites.end())" -->
auto&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()-&gt;decltype(VecSites.end())</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adae35aa02ee23e83a7db867e88aa1dc7"></a><!-- doxytag: member="NGS::uGenericNGSChrom::generateRandomSite" ref="adae35aa02ee23e83a7db867e88aa1dc7" args="(const int size_, std::mt19937 &amp;engine, const uGenericNGSChrom&lt; T2 &gt; &amp;exclList, const int sigma, const std::string ID) const" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_n_g_s_1_1u_tags.html">uTags</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>generateRandomSite</b> (const int size_, std::mt19937 &amp;engine, const <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; T2 &gt; &amp;exclList, const int sigma, const std::string ID) const</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affec560200ebc654f3215c73917f8db6"></a><!-- doxytag: member="NGS::uGenericNGSChrom::returnSiteSizes" ref="affec560200ebc654f3215c73917f8db6" args="() const " -->
std::vector&lt; long long &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>returnSiteSizes</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#adb5f7679e406849b77966d282bacff4a">avgSiteSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return average element size.  <a href="#adb5f7679e406849b77966d282bacff4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4756cc780d1066220db34ea7103a4734"></a><!-- doxytag: member="NGS::uGenericNGSChrom::minSiteSize" ref="a4756cc780d1066220db34ea7103a4734" args="() const " -->
unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><b>minSiteSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2e3349232ec0ed622e50740b190ca65"></a><!-- doxytag: member="NGS::uGenericNGSChrom::maxSiteSize" ref="ae2e3349232ec0ed622e50740b190ca65" args="() const " -->
unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><b>maxSiteSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a1b29d8b94b2dd1186c75820311c0a41b">sumSiteSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return sum of sizes, including overlapping.  <a href="#a1b29d8b94b2dd1186c75820311c0a41b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51e09e345e311ff3aeb544edbbc220c"></a><!-- doxytag: member="NGS::uGenericNGSChrom::chr" ref="ad51e09e345e311ff3aeb544edbbc220c" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>chr</b> = &quot;&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a8efe406aee4356ad742bf97dd404d458">m_isSorted</a> = true</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae306d0d177f1d076251c50c8730df5f4"></a><!-- doxytag: member="NGS::uGenericNGSChrom::sortGetStart" ref="ae306d0d177f1d076251c50c8730df5f4" args=")" -->
std::function&lt; float(const <br class="typebreak"/>
_BASE_ *)&nbsp;</td><td class="memItemRight" valign="bottom"><b>sortGetStart</b> ) = nullptr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcc0f5008a3fb0ebd7ce2374e256d386"></a><!-- doxytag: member="NGS::uGenericNGSChrom::sortGetEnd" ref="abcc0f5008a3fb0ebd7ce2374e256d386" args=")" -->
std::function&lt; float(const <br class="typebreak"/>
_BASE_ *)&nbsp;</td><td class="memItemRight" valign="bottom"><b>sortGetEnd</b> ) = nullptr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6820e348d6c8c21ddd1d9c5d3e48c642"></a><!-- doxytag: member="NGS::uGenericNGSChrom::m_comptFunc" ref="a6820e348d6c8c21ddd1d9c5d3e48c642" args="" -->
std::function&lt; bool(const <br class="typebreak"/>
_BASE_ &amp;item1, const _BASE_ <br class="typebreak"/>
&amp;item2)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_comptFunc</b> = compareStart</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd10be06260f1ba40ed3102f8e98262"></a><!-- doxytag: member="NGS::uGenericNGSChrom::chromSize" ref="a8cd10be06260f1ba40ed3102f8e98262" args="" -->
long int&nbsp;</td><td class="memItemRight" valign="bottom"><b>chromSize</b> = 0</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed08e81515b25365e6897db1e7ab9575"></a><!-- doxytag: member="NGS::uGenericNGSChrom::uGenericNGSExperiment" ref="aed08e81515b25365e6897db1e7ab9575" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>uGenericNGSExperiment</b></td></tr>
</table>
<h3>template&lt;typename _BASE_&gt;<br/>
 class NGS::uGenericNGSChrom&lt; _BASE_ &gt;</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9a78b5ccc122f01af19661d0096544ae"></a><!-- doxytag: member="NGS::uGenericNGSChrom::~uGenericNGSChrom" ref="a9a78b5ccc122f01af19661d0096544ae" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::~<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write functions </p>

</div>
</div>
<a class="anchor" id="a20a6b72a8830cab80c00fa2685b36a6b"></a><!-- doxytag: member="NGS::uGenericNGSChrom::uGenericNGSChrom" ref="a20a6b72a8830cab80c00fa2685b36a6b" args="(std::string consString, long int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>consString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct with name and size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>consString</em>&nbsp;</td><td>std::string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>long int </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5c23b9fbde17c1ad07dbc60517ead481"></a><!-- doxytag: member="NGS::uGenericNGSChrom::accumulateSitesInfo" ref="a5c23b9fbde17c1ad07dbc60517ead481" args="(BinaryOperation binary_op, InitialValue init) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class BinaryOperation , class InitialValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InitialValue <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::accumulateSitesInfo </td>
          <td>(</td>
          <td class="paramtype">BinaryOperation&nbsp;</td>
          <td class="paramname"> <em>binary_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InitialValue&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate information by querying all sites. </p>
<p>This function take a pointer to a function to accumulate some information; this function pointer can either be a) the name of a function taking two parameters, an accumulator and a site or b) a lambda function taking two parameters, an accumulator and a site. In all cases, the function must return the new value of the accumulator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>binary_op</em>&nbsp;</td><td>BinaryOperation : Querying function to perform on the sites collection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>InitialValue The initial value of the "accumulator" </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The information accumulated by querying all the sites End STL wrappers </dd></dl>

</div>
</div>
<a class="anchor" id="aba4e0d6c33afa5c9b21049800d3c26d4"></a><!-- doxytag: member="NGS::uGenericNGSChrom::addSite" ref="aba4e0d6c33afa5c9b21049800d3c26d4" args="(_BASE_ newSite)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::addSite </td>
          <td>(</td>
          <td class="paramtype">_BASE_&nbsp;</td>
          <td class="paramname"> <em>newSite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>add a new element to our chrom, throw out_of_mem if impossible </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newSite</em>&nbsp;</td><td>_BASE_ Ellement to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d0fc188e5e4fbe9ff84ea191ef70d22"></a><!-- doxytag: member="NGS::uGenericNGSChrom::applyOnAllSites" ref="a2d0fc188e5e4fbe9ff84ea191ef70d22" args="(UnaryOperation f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryOperation <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::applyOnAllSites </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the sites collection by applying a certain function to all sites. </p>
<p>This function take a pointer to a function to transform the sites collection; this function pointer can either be a) the name of a function taking a site by reference, b) a lambda function taking a site by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>unary_op, the operation that was performed on all sites </dd></dl>

</div>
</div>
<a class="anchor" id="adb5f7679e406849b77966d282bacff4a"></a><!-- doxytag: member="NGS::uGenericNGSChrom::avgSiteSize" ref="adb5f7679e406849b77966d282bacff4a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::avgSiteSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return average element size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>unsigned long long </dd></dl>

</div>
</div>
<a class="anchor" id="a373facfa4538e9d3ce035b197855cb02"></a><!-- doxytag: member="NGS::uGenericNGSChrom::begin" ref="a373facfa4538e9d3ce035b197855cb02" args="()&#45;&gt;decltype(VecSites.begin())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Private iterators </p>

</div>
</div>
<a class="anchor" id="a24e63c9701505c27a3d1be8fa2e31e8a"></a><!-- doxytag: member="NGS::uGenericNGSChrom::computeOnAllSites" ref="a24e63c9701505c27a3d1be8fa2e31e8a" args="(UnaryOperation unary_op)&#45;&gt; std" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::computeOnAllSites </td>
          <td>(</td>
          <td class="paramtype">UnaryOperation&nbsp;</td>
          <td class="paramname"> <em>unary_op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a value for all sites in the chromosome and return the resulting collection. </p>
<p>Wrappers around the STL algorithms This function take a pointer to a function to perform on all the sites in the collection; this function pointer can either be a) the name of a function taking a site by reference, b) a lambda function taking a site by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return a non void value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on all the sites of the chromosome </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A collection of values computed on each site by unary_op Create a copy of the sites vector, transform it and return the copy This function take a pointer to a function to transform the copied sites vector; this function pointer can either be a) the name of a function taking a site by reference, b) a lambda function taking a site by reference or c) a member method of a site using "mem_fun_ref". In all cases, the function must return void (any other return value will be ignored).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unary_op</em>&nbsp;</td><td>UnaryOperation : Unary operation to perform on the copied sites vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of the same type and length as the sites vector but with its sites transformed by unary_op </dd></dl>

</div>
</div>
<a class="anchor" id="afac963887607b1a6b0694eb8612e2293"></a><!-- doxytag: member="NGS::uGenericNGSChrom::countSitesWithProperty" ref="afac963887607b1a6b0694eb8612e2293" args="(UnaryPredicate p) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;VecGenIter&gt;::difference_type <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::countSitesWithProperty </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the number of sites for which a certain predicate is true. </p>
<p>This function take a pointer to a predicate function; this function pointer can either be a) the name of a function taking a site as parameter, b) a lambda function taking a site as parameter or c) a member method of a site using "mem_fun_ref". In all cases, the function must return a boolean; true is the predicate is true, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>UnaryPredicate : Unary predicate to evaluate on all sites </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of sites for which a certain predicate is true End STL wrappers Constructors </dd></dl>

</div>
</div>
<a class="anchor" id="ac5b4972114393cb342415b4a8a52eeaf"></a><!-- doxytag: member="NGS::uGenericNGSChrom::countUnique" ref="ac5b4972114393cb342415b4a8a52eeaf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long int <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::countUnique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public iterators </p>

</div>
</div>
<a class="anchor" id="a184e00646860b74d0f27bae38452b747"></a><!-- doxytag: member="NGS::uGenericNGSChrom::divideItemsIntoBinofSize" ref="a184e00646860b74d0f27bae38452b747" args="(int N, SplitType type=SplitType::STRICT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::divideItemsIntoBinofSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SplitType::STRICT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide each member into smaller members of size N, sorting the leftover according to our SplitType. </p>
<p>Find according to sort value</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>int : Size of the members to build in BP </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>SplitType : How to manage splits that are not a multiple of N. Possible : STRICT - IGNORE - FILL - ADD </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ab868dd6578267b54bda07a2cfd6f5505"></a><!-- doxytag: member="NGS::uGenericNGSChrom::divideItemsIntoNBins" ref="ab868dd6578267b54bda07a2cfd6f5505" args="(int N, SplitType type=SplitType::STRICT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::divideItemsIntoNBins </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitType&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SplitType::STRICT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split each item into smaller equal size members and replace our vector of items with the new one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>int : Number of bins to make </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>SplitType : How to manage splits that are not a multiple of N. Possible : STRICT - IGNORE - FILL - ADD </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a9dc4ee72a213ba76b81cfb21cca36441"></a><!-- doxytag: member="NGS::uGenericNGSChrom::findNextSite" ref="a9dc4ee72a213ba76b81cfb21cca36441" args="(const float position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; _BASE_ &gt;::const_iterator <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::findNextSite </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions to create and add items to our chrom </p>

<p><p>&lt; If unsorted, fail</p>
<p>&lt; Return true comparitor if item1 smaller then item 2</p>
<p>&lt; Compare, sort Value</p>
<p>&lt; If no result, or result is our first item</p>
<p>&lt;Return the item greater then value </p>
</p>

</div>
</div>
<a class="anchor" id="a3d07b9493b8e1d89f0682a9480f8c926"></a><!-- doxytag: member="NGS::uGenericNGSChrom::findPrecedingSite" ref="a3d07b9493b8e1d89f0682a9480f8c926" args="(const float position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; _BASE_ &gt;::const_iterator <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::findPrecedingSite </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find first item preceding a given value for our current sort type. Data must be sorted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>const int&amp; Position to evaluate fro </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>typename std::vector&lt;_BASE_&gt;::const_iterator </dd></dl>

<p><p>&lt; If unsorted, fail</p>
<p>&lt; Compare, sort Value</p>
<p>&lt; If no result, or result is our first item</p>
<p>&lt;Return item precedes and as such is LESS then position </p>
</p>

</div>
</div>
<a class="anchor" id="a5a38257e7c63a847d6744cf8fa00271c"></a><!-- doxytag: member="NGS::uGenericNGSChrom::generateRandomSite" ref="a5a38257e7c63a847d6744cf8fa00271c" args="(const int size, std::mt19937 &amp;engine, const int sigma=0, const std::string ID=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BASE_ <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::generateRandomSite </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&nbsp;</td>
          <td class="paramname"> <em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sigma</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>ID</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>const int size of the region to generate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>engine</em>&nbsp;</td><td>std::mt19937&amp; type of engine to use, see manual for details </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>const int Standard deviation if we wish to introduct randomness </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ID</em>&nbsp;</td><td>const std::string Name of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>_BASE_ the Element returned </dd></dl>

</div>
</div>
<a class="anchor" id="adcbb0ab03b3d08f03e5adbef3af160a5"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getChr" ref="adcbb0ab03b3d08f03e5adbef3af160a5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getChr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return name of the element. </p>

</div>
</div>
<a class="anchor" id="a5916a4a249e0603245a00481497568fd"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getChromSize" ref="a5916a4a249e0603245a00481497568fd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getChromSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return size </p>

</div>
</div>
<a class="anchor" id="af40976c64bf6a698ca0687d6461a17f7"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getDistinct" ref="af40976c64bf6a698ca0687d6461a17f7" args="(std::string chr, int start, int end, OverlapType options=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getDistinct </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions to manipulate generically ranges of our elements</p>
<p>Return the elements of A that do not overlap B </p>

</div>
</div>
<a class="anchor" id="a22b84b392703c323740c8c9b2b4e09f8"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getSite" ref="a22b84b392703c323740c8c9b2b4e09f8" args="(int position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BASE_ <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getSite </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return copy of the element at .<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a373facfa4538e9d3ce035b197855cb02">begin()</a>+position count from iterator </p>

</div>
</div>
<a class="anchor" id="a36d32f9c25058c20674309b6202116d2"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getSortedStatus" ref="a36d32f9c25058c20674309b6202116d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getSortedStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return number of elements </p>

</div>
</div>
<a class="anchor" id="a65e5ec272677a8de6427b2ec651a23f5"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getSpecificSites" ref="a65e5ec272677a8de6427b2ec651a23f5" args="(UnaryPredicate pred) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;_BASE_&gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getSpecificSites </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sites for which a certain predicate is true. </p>
<p>This function take a pointer to a predicate function; this function pointer can either be a) the name of a function taking a site as parameter, b) a lambda function taking a site as parameter or c) a member method of a site using "mem_fun_ref". In all cases, the function must return a boolean; true is the predicate is true, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>UnaryPredicate : Unary predicate to evaluate on all sites </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A collection containing all the sites for which the predicate is true </dd></dl>

</div>
</div>
<a class="anchor" id="a0ba1c72585a69863e62e83123b6113c2"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getSubset" ref="a0ba1c72585a69863e62e83123b6113c2" args="(float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getSubset </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>overlap</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a subset of our data that overlaps range start/end, based on current sort type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>int Start of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>int End of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlap</em>&nbsp;</td><td>OverlapType Type of overlap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uGenericNGSChrom&lt;_BASE_&gt; Chrom structure containing our element subset </dd></dl>

<p><p>&lt; If no tag leftwise, we start at beginning </p>
</p>

</div>
</div>
<a class="anchor" id="aed39f7a2f063bd2cabb41d34460d9b89"></a><!-- doxytag: member="NGS::uGenericNGSChrom::getSubsetCount" ref="aed39f7a2f063bd2cabb41d34460d9b89" args="(float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::getSubsetCount </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>overlap</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the count of a data subset, based on the current sort type. Please see manual for correct usage of this category of function </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>int start interval value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>int end interval value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlap</em>&nbsp;</td><td>OverlapType OverlapType from Enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int Number of elements in our range </dd></dl>

<p><p>&lt; If no tag leftwise, we start at beginning </p>
</p>

</div>
</div>
<a class="anchor" id="aa375dd388e7bdf9ad0759a5168bd20fe"></a><!-- doxytag: member="NGS::uGenericNGSChrom::isSorted" ref="aa375dd388e7bdf9ad0759a5168bd20fe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::isSorted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if the sites collection is sorted ascendingly according to their start position. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the sites are sorted, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4abf5d52df7b9e0107c35b7e9b18c8"></a><!-- doxytag: member="NGS::uGenericNGSChrom::isSorted" ref="a0b4abf5d52df7b9e0107c35b7e9b18c8" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::isSorted </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if the sites collection is sorted according to a certain comparison. </p>
<p>This function take a pointer to a function to determine if the the sites collection is sorted; this function pointer can either be a) the name of a function taking two sites as parameters, b) a lambda function taking two sites as parameters or c) a member method of a site taking another site as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the sites are sorted, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c73ad4d4eafa9495a19b6ec1326ce34"></a><!-- doxytag: member="NGS::uGenericNGSChrom::maxSite" ref="a9c73ad4d4eafa9495a19b6ec1326ce34" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VecGenConstIter <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::maxSite </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the maximal site according to a certain comparison. </p>
<p>This function take a pointer to a function to find the maximal site; this function pointer can either be a) the name of a function taking two sites as parameters, b) a lambda function taking two sites as parameters or c) a member method of a site taking another site as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the maximal site </dd></dl>

</div>
</div>
<a class="anchor" id="a445dec74ed2220a7c777ea46783c6db5"></a><!-- doxytag: member="NGS::uGenericNGSChrom::minAndMaxSites" ref="a445dec74ed2220a7c777ea46783c6db5" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;VecGenConstIter, VecGenConstIter&gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::minAndMaxSites </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the minimal and maximal sites according to a certain comparison. </p>
<p>This function take a pointer to a function to find the minimal and maximal sites; this function pointer can either be a) the name of a function taking two sites as parameters, b) a lambda function taking two sites as parameters or c) a member method of a site taking another site as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators: the first indicates the minimal site and the second, the maximal site </dd></dl>

</div>
</div>
<a class="anchor" id="ae62494273a84d618bb17f7d21f68eb0f"></a><!-- doxytag: member="NGS::uGenericNGSChrom::minSite" ref="ae62494273a84d618bb17f7d21f68eb0f" args="(Compare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VecGenConstIter <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::minSite </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the minimal site according to a certain comparison. </p>
<p>This function take a pointer to a function to find the minimal site; this function pointer can either be a) the name of a function taking two sites as parameters, b) a lambda function taking two sites as parameters or c) a member method of a site taking another site as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the minimal site </dd></dl>

</div>
</div>
<a class="anchor" id="a8d95d9b7a55b22e8b3de26e937872a40"></a><!-- doxytag: member="NGS::uGenericNGSChrom::printStats" ref="a8d95d9b7a55b22e8b3de26e937872a40" args="(std::ostream &amp;out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::printStats </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In place </p>

<p><p>&lt; Get a vector containing the lenght of every site </p>
</p>

</div>
</div>
<a class="anchor" id="a339b7e7166b89458304d15a130c49705"></a><!-- doxytag: member="NGS::uGenericNGSChrom::removeSpecificSites" ref="a339b7e7166b89458304d15a130c49705" args="(UnaryPredicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::removeSpecificSites </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove sites for which the predicate is true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>UnaryPredicate Predicate to test, follows standard pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a7e09651073fba5b980fcaae21b51c958"></a><!-- doxytag: member="NGS::uGenericNGSChrom::removeSubset" ref="a7e09651073fba5b980fcaae21b51c958" args="(float start, float end, OverlapType overlap=OverlapType::OVERLAP_PARTIAL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">uGenericNGSChrom</a>&lt; _BASE_ &gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::removeSubset </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OverlapType&nbsp;</td>
          <td class="paramname"> <em>overlap</em> = <code>OverlapType::OVERLAP_PARTIAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return a subSet based on the current comparison value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>int </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>int </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlap</em>&nbsp;</td><td>OverlapType </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uGenericNGSChrom&lt;_BASE_&gt; Return elements of A that overlap B </dd></dl>

<p><p>&lt; If no tag leftwise, we start at beginning</p>
<p>&lt; When we find a valid element, go back one step and erase th element </p>
</p>

</div>
</div>
<a class="anchor" id="a204206f40cee44b3bfed9883466cb8c1"></a><!-- doxytag: member="NGS::uGenericNGSChrom::returnVecData" ref="a204206f40cee44b3bfed9883466cb8c1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;_BASE_&gt; <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::returnVecData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a vector containing all elements. </p>

</div>
</div>
<a class="anchor" id="a9db4be4700962c62a316e0d4d4fd4e04"></a><!-- doxytag: member="NGS::uGenericNGSChrom::setChr" ref="a9db4be4700962c62a316e0d4d4fd4e04" args="(std::string pchr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::setChr </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>pchr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set name of the element. Be careful about this, can throw of Experiment mapping </p>

</div>
</div>
<a class="anchor" id="a5b2f432a7bbbb9a8bafa275e43963329"></a><!-- doxytag: member="NGS::uGenericNGSChrom::setChromSize" ref="a5b2f432a7bbbb9a8bafa275e43963329" args="(long int chromS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::setChromSize </td>
          <td>(</td>
          <td class="paramtype">long int&nbsp;</td>
          <td class="paramname"> <em>chromS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set element collection max size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chromS</em>&nbsp;</td><td>long int size to set as </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a65beb951fddad09f5c9fc450718e158c"></a><!-- doxytag: member="NGS::uGenericNGSChrom::sortSites" ref="a65beb951fddad09f5c9fc450718e158c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::sortSites </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default sort using the start position as a the comparison point. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a8f41ebe6fe8599edac708013695ac125"></a><!-- doxytag: member="NGS::uGenericNGSChrom::sortSites" ref="a8f41ebe6fe8599edac708013695ac125" args="(Compare comp, std::function&lt; float(const _BASE_ *)&gt; getStart_funct=nullptr, std::function&lt; float(const _BASE_ *)&gt; getEnd_funct=nullptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::sortSites </td>
          <td>(</td>
          <td class="paramtype">Compare&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float(const _BASE_ *)&gt;&nbsp;</td>
          <td class="paramname"> <em>getStart_funct</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; float(const _BASE_ *)&gt;&nbsp;</td>
          <td class="paramname"> <em>getEnd_funct</em> = <code>nullptr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the sites vector by applying a certain comparison. </p>
<p>This function take a pointer to a function to sort the sites collection; this function pointer can either be a) the name of a function taking two sites as parameters, b) a lambda function taking two sites as parameters or c) a member method of a site taking another site as parameter using "mem_fun_ref". In all cases, the function must return a boolean: true if the first element is "lower" than the second, false otherwise.</p>
<p>Addtionally, one may provide a pointer to related getters. This enables the use of <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a0ba1c72585a69863e62e83123b6113c2" title="Return a subset of our data that overlaps range start/end, based on current sort...">getSubset()</a> and <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a7e09651073fba5b980fcaae21b51c958" title="return a subSet based on the current comparison value">removeSubset()</a> on the appropriate type of sort</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>Compare : Binary comparison operation to perform on the sites collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a1b29d8b94b2dd1186c75820311c0a41b"></a><!-- doxytag: member="NGS::uGenericNGSChrom::sumSiteSize" ref="a1b29d8b94b2dd1186c75820311c0a41b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _BASE_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::sumSiteSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return sum of sizes, including overlapping. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>unsigned long long </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a8efe406aee4356ad742bf97dd404d458"></a><!-- doxytag: member="NGS::uGenericNGSChrom::m_isSorted" ref="a8efe406aee4356ad742bf97dd404d458" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BASE_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html">NGS::uGenericNGSChrom</a>&lt; _BASE_ &gt;::<a class="el" href="class_n_g_s_1_1u_generic_n_g_s_chrom.html#a8efe406aee4356ad742bf97dd404d458">m_isSorted</a> = true<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Pointers to our functions and determines if sorted </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="u_format_chrom_8h_source.html">uFormatChrom.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Nov 8 15:47:06 2012 for geneClass by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
